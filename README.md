# c

一、 核心概念：什么是数组越界？
当你定义一个数组 int arr[5]; 时，系统只为你分配了 5 个格子的空间。

合法下标范围： 0 到 4。

非法下标： 任何小于 0 或大于等于 5 的数字（如 arr[5]）。

致命误区： 很多初学者认为 int arr[5] 的最后一个元素是 arr[5]，这是错误的。arr[5] 实际上是数组后面紧邻的内存位置，属于“别人的地盘”。

二、 常见越界场景（考试常考）
1. “差一错误” (Off-by-one Error) —— 最经典
在 for 循环中错误地使用了 <= 导致多访问了一次。

C++

int a[10];
// 错误写法：i <= 10
// 当 i = 10 时，访问 a[10]，发生越界
for (int i = 0; i <= 10; i++) { 
    a[i] = i; 
}
// 正确写法：i < 10
2. 字符串拼接溢出
C 风格字符串需要一个额外的 '\0' 结束符。如果数组大小只够存字符，没有位置存 '\0'，或者拼接后总长度超过数组容量，就会越界。

C++

char str[5] = "Hello"; // 错误！
// "Hello" 有 5 个字母，加上 '\0' 共需 6 个字节。
// str[5] 只能存 5 个，'\0' 被丢弃或写到了非法内存中。
3. 数组下标做运算
当数组下标是一个变量计算的结果时，很容易失控。

C++

int arr[5] = {0};
int k = 10;
// 如果 k 的值未经检查直接做下标，很容易越界
arr[k-7] = 1; // 访问 arr[3]，合法
arr[k-4] = 1; // 访问 arr[6]，越界！
三、 针对性实战练习
请分析以下代码片段，指出是否存在越界问题，并说明后果或输出。

练习题 1：循环条件的判断
C++

int arr[5] = {1, 2, 3, 4, 5};
int sum = 0;
for (int i = 1; i <= 5; i++) {
    sum += arr[i];
}
cout << sum << endl;
问题： 这段代码能正确计算 1 到 5 的和吗？如果不可以，为什么？

练习题 2：字符数组的陷阱
C++

char s1[10] = "abc";
char s2[] = "def";
int i = 0;
// 试图将 s2 拼接到 s1 后面
while (s2[i] != '\0') {
    s1[3 + i] = s2[i]; // 'd' 存入 s1[3], 'e' 存入 s1[4]...
    i++;
}
cout << s1 << endl;
问题： 输出结果会是 abcdef 吗？代码有没有逻辑漏洞？（提示：s1 的结束符去哪了？）

练习题 3：越界导致的死循环（高难度，了解即可）
C++

// 某些特定的编译器/内存布局下会出现这种情况
void func() {
    int i;
    int arr[3];
    // 注意：这里的循环条件是 i <= 3
    for (i = 0; i <= 3; i++) {
        arr[i] = 0;
        printf("Hello\n");
    }
}
问题： 为什么这段代码可能会陷入死循环？

✅ 答案与解析
练习题 1 解析
存在越界。

分析：

数组 arr 的有效下标是 0 到 4。

循环从 i=1 开始，漏掉了 arr[0] (值为 1)。

循环结束条件是 i <= 5，最后一次会访问 arr[5]。这是越界访问。

后果： arr[5] 的值是内存中的垃圾值（随机数）。sum 的结果将是 2+3+4+5 + 一个随机数，结果完全不可控。

练习题 2 解析
存在逻辑错误（虽然未立即崩溃，但结果不正确）。

分析：

循环将 s2 的字符 'd', 'e', 'f' 依次填入了 s1[3], s1[4], s1[5]。

此时 s1 的内容变成了：'a', 'b', 'c', 'd', 'e', 'f', ...

关键点： 代码没有在新字符串的末尾手动添加 '\0'。

cout 在打印字符串时，会一直打印直到遇到 '\0' 为止。

后果： 输出可能是 abcdef 后面跟一堆乱码，直到内存中偶然出现一个 0 为止。

练习题 3 解析
死循环原理：

局部变量 i 和数组 arr 都在栈上分配内存。在很多系统中，变量是按照地址从高到低分配的。

内存布局可能是：[i] [arr[2]] [arr[1]] [arr[0]]。

当 i = 3 时，程序试图写入 arr[3]。

如果 arr[3] 的内存地址恰好就是变量 i 的地址，那么 arr[3] = 0 实际上执行的是 i = 0。

这导致循环变量 i 被重置为 0，循环永远无法结束。
